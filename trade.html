    // Initialize contracts
    const usdcContract = new web3.eth.Contract(USDC_ABI, USDCContractAddress);
    const saleContract = new web3.eth.Contract(SALE_CONTRACT_ABI, contractAddress);

    // Check user USDC balance
    const balance = await usdcContract.methods.balanceOf(userAddress).call();
    if (web3.utils.toBN(balance).lt(usdcAmountUnits)) {
      alert('Insufficient USDC balance.');
      buyStatus.textContent = '';
      buyBtn.disabled = false;
      return;
    }

    // Check allowance
    const allowance = await usdcContract.methods.allowance(userAddress, contractAddress).call();
    if (web3.utils.toBN(allowance).lt(usdcAmountUnits)) {
      buyStatus.textContent = 'Approving USDC... Please confirm in your wallet.';
      // Approve USDC spending by the sale contract
      await usdcContract.methods.approve(contractAddress, usdcAmountUnits).send({ from: userAddress });
      buyStatus.textContent = 'USDC approved. Proceeding with purchase...';
    }

    // Call buy function with usdcAmountUnits
    await saleContract.methods.buy(usdcAmountUnits).send({ from: userAddress });
    buyStatus.textContent = `Success! You bought ${amountDrf} ${tokenSymbol} tokens.`;
    buyAmountInput.value = '';
  } catch (err) {
    console.error(err);
    buyStatus.textContent = 'Transaction failed or rejected.';
    alert('Transaction failed or rejected.');
  } finally {
    buyBtn.disabled = false;
  }
});

// Auto-connect wallet if already authorized (optional)
window.addEventListener('load', async () => {
  if (window.ethereum && window.ethereum.selectedAddress) {
    await connectWallet();
  }
});
